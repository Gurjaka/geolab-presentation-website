## **სლაიდი 1: შესავალი**

- მოგესალმებით. დღეს მინდა გაგიზიაროთ ჩემი გამოცდილება პერსონალიზებული სარეკომენდაციო სისტემის შექმნის შესახებ. პროექტის მიზანი იყო არა მხოლოდ მუშა ალგორითმის შექმნა, არამედ მაღალეფექტური და სკალირებადი სისტემის აგება, რომელიც რეალურ გამოწვევებს პასუხობს. ჩემს პროექტში გამოვიყენე Python-ის ეკოსისტემა, კერძოდ Scikit-learn ვექტორიზაციისთვის, FAISS ძიების ოპტიმიზაციისთვის და Gradio მომხმარებელთან ინტერაქციისთვის.

## **სლაიდი 2: გამოწვევები და პრობლემის ფორმულირება**

- ნებისმიერი AI პროექტი იწყება პრობლემის იდენტიფიცირებით. სარეკომენდაციო სისტემებში მთავარი გამოწვევა ე.წ. 'Cold Start' პრობლემაა — როგორ მივცეთ რეკომენდაცია ახალ მომხმარებელს, რომლის ისტორიაც არ გაგვაჩნია? ასევე, მნიშვნელოვანი იყო მონაცემთა დეფიციტისა და სათაურების ინკონსისტენტობის საკითხი, რაც ხშირად ხდება სისტემის გაუმართაობის მიზეზი. ჩვენი ამოცანა იყო ამ ბარიერების ტექნიკური გადაჭრა.

## **სლაიდი 3: მონაცემებზე დაფუძნებული ჰიბრიდული რეკომენდაციის სისტემა**

- სლაიდზე მოცემული გვაქს პატარა დიაგრამა რაც გვაჩვენებს იმ გზას რომელსაც ჩვენი "პროგრამა" გაივლის.

## **სლაიდი 4: მონაცემთა ინჟინერია და პრეპროცესინგი**

- ბრიფის მიხედვით, მონაცემთა დამუშავება ერთ-ერთი კრიტიკული ეტაპი იყო. გამოვიყენე difflib ბიბლიოთეკა Fuzzy Matching-ისთვის, რათა სისტემას შეძლებოდა მომხმარებლის მიერ შეყვანილი არაზუსტი სათაურების ამოცნობა. ტექსტური მონაცემები გარდავქმენით TF-IDF მატრიცებად. გარდა ამისა, ჩავატარეთ სუბსემპლინგი, რამაც საშუალება მოგვცა შეგვენარჩუნებინა გამოთვლითი ეფექტურობა ისე, რომ მოდელის სიზუსტე არ დაზარალებულიყო.

## **სლაიდი 5: ჰიბრიდული მოდელის არქიტექტურა**

- სისტემის ხერხემალი ჰიბრიდული არქიტექტურაა. ჩვენ გავაერთიანეთ ორი მიდგომა: Content-Based, რომელიც ეყრდნობა ფილმების მახასიათებლებს, და Collaborative Filtering, რომელიც ითვალისწინებს მომხმარებელთა საერთო ქცევას. ეს კომბინაცია საშუალებას გვაძლევს, ერთის მხრივ, გადავჭრათ Cold Start პრობლემა და, მეორეს მხრივ, შევთავაზოთ მაღალი დონის პერსონალიზაცია გამოცდილ მომხმარებლებს.

## **სლაიდი 6: სისტემური ოპტიმიზაცია: FAISS**

- როგორც დეველოპერისთვის, ჩემთვის პრიორიტეტული იყო წარმადობა. სტანდარტული კოსინუსური მსგავსების გამოთვლა დიდ მონაცემებზე ნელია. სწორედ ამიტომ, სისტემაში მოვახდინეთ FAISS-ის ინტეგრაცია. ეს არის Facebook AI-ს მიერ შექმნილი ბიბლიოთეკა, რომელიც იყენებს ვექტორულ ინდექსირებას. შედეგად, უახლოესი მეზობლების ძებნის სირთულე O(n)-დან O(logn)-მდე შევამცირეთ, რაც სისტემას სკალირებადს ხდის.

## **სლაიდი 7: შედარებითი ანალიზი და ვალიდაცია**

- ვალიდაციის ეტაპზე შევადარეთ ჰიბრიდული მოდელი ცალკეულ კომპონენტებს. ტესტებმა აჩვენა, რომ ჰიბრიდული მიდგომა ბევრად უფრო სტაბილურ შედეგებს იძლევა. პროცესის გამჭვირვალობისთვის დავნერგეთ დებაგირების ლოგები, რაც საშუალებას გვაძლევს დავინახოთ, თუ რატომ შეირჩა ესა თუ ის ფილმი. ვიზუალიზაციამ კი დაგვანახა ჩვენს Dataset-ში არსებული ჟანრობრივი განაწილება და რეიტინგების ტენდენციები.

## **სლაიდი 8: ინტერფეისი და დოკუმენტაცია**

- პროექტი დასრულებულად ვერ ჩაითვლება, თუ ის მომხმარებლისთვის ხელმისაწვდომი არ არის. Gradio-ს მეშვეობით შევქმენით ინტერაქტიული UI, სადაც რეკომენდაციების მიღება წამებშია შესაძლებელი. ასევე, განსაკუთრებული ყურადღება დავუთმეთ ტექნიკურ დოკუმენტაციას და ვებ-გვერდს, სადაც დეტალურადაა აღწერილი კოდის სტრუქტურა და აბსტრაქციები. ეს მნიშვნელოვანია პროექტის რეპროდუცირებადობისთვის.

## **სლაიდი 9: დასკვნა და სამომავლო პერსპექტივები**

- შეჯამების სახით ვიტყვი, რომ ეს პროექტი იყო გზა მარტივი ალგორითმიდან ოპტიმიზებულ სისტემამდე. პირადი გამოცდილებიდან გირჩევთ: ნუ შემოიფარგლებით მხოლოდ მინიმალური მოთხოვნებით, ეძებეთ ოპტიმიზაციის გზები და ყოველთვის დასვით კითხვა — როგორ იმუშავებს ჩემი კოდი დიდ მონაცემებზე? გმადლობთ ყურადღებისთვის, მზად ვარ ვუპასუხო თქვენს კითხვებს.
